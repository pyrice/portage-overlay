diff --git a/schedule/__init__.py b/schedule/__init__.py
index 45a6f1d..f7aac71 100644
--- a/schedule/__init__.py
+++ b/schedule/__init__.py
@@ -44,7 +44,12 @@ import logging
 import random
 import time
 
-logger = logging.getLogger('schedule')
+try:
+    from datetime import timezone
+    utc = timezone.utc
+except ImportError:
+    from schedule.timezone import UTC
+    utc = UTC()
 
 
 class CancelJob(object):
@@ -62,6 +67,7 @@ class Scheduler(object):
     """
     def __init__(self):
         self.jobs = []
+        self.logger = logging.getLogger('schedule.Scheduler')
 
     def run_pending(self):
         """
@@ -77,19 +83,30 @@ class Scheduler(object):
         for job in sorted(runnable_jobs):
             self._run_job(job)
 
-    def run_all(self, delay_seconds=0):
+    def run_all(self, delay_seconds=0, tag=None):
         """
-        Run all jobs regardless if they are scheduled to run or not.
+        Run all jobs regardless if they are scheduled to run or not,
+        optionally matching one or more tags.
 
         A delay of `delay` seconds is added between each job. This helps
         distribute system load generated by the jobs more evenly
         over time.
 
         :param delay_seconds: A delay added between every executed job
+
+        :param tag: An identifier used to identify a subset of
+                    jobs to run
         """
-        logger.info('Running *all* %i jobs with %is delay inbetween',
-                    len(self.jobs), delay_seconds)
-        for job in self.jobs[:]:
+
+        if tag is None:
+            runnable_jobs = self.jobs[:]
+        else:
+            runnable_jobs = (job for job in self.jobs if tag in job.tags)
+
+        self.logger.info('Running *all* %i jobs with %is delay inbetween',
+                         len(self.jobs), delay_seconds)
+
+        for job in sorted(runnable_jobs):
             self._run_job(job)
             time.sleep(delay_seconds)
 
@@ -102,8 +119,10 @@ class Scheduler(object):
                     jobs to delete
         """
         if tag is None:
+            self.logger.info('Deleting *all* jobs')
             del self.jobs[:]
         else:
+            self.logger.info('Deleting all jobs tagged "%s"', tag)
             self.jobs[:] = (job for job in self.jobs if tag not in job.tags)
 
     def cancel_job(self, job):
@@ -149,7 +168,27 @@ class Scheduler(object):
         :return: Number of seconds until
                  :meth:`next_run <Scheduler.next_run>`.
         """
-        return (self.next_run - datetime.datetime.now()).total_seconds()
+        return (self.next_run - datetime.datetime.now(utc)).total_seconds()
+
+    @property
+    def last_run(self):
+        """
+        Datetime when the last job ran (check for NoneType before using).
+
+        :return: A :class:`~datetime.datetime` object
+        """
+        if not self.jobs:
+            return None
+        return max(self.jobs).last_run
+
+    @property
+    def idle_seconds_since(self):
+        """
+        :return: Number of seconds since (check for NoneType before using).
+                 :meth:`next_run <Scheduler.next_run>`.
+        """
+        if self.last_run is not None:
+            return (datetime.datetime.now(utc) - self.last_run).total_seconds()
 
 
 class Job(object):
@@ -173,6 +212,8 @@ class Job(object):
         self.interval = interval  # pause interval * unit between runs
         self.latest = None  # upper limit to the interval
         self.job_func = None  # the job job_func to run
+        self.job_name = None  # the name of job_func to run
+        self.job_info = None  # the job timestats (see below)
         self.unit = None  # time units, e.g. 'minutes', 'hours', ...
         self.at_time = None  # optional time at which this job runs
         self.last_run = None  # datetime of the last run
@@ -181,6 +222,7 @@ class Job(object):
         self.start_day = None  # Specific day of the week to start on
         self.tags = set()  # unique set of tags for the job
         self.scheduler = scheduler  # scheduler to register with
+        self.logger = logging.getLogger('schedule.Job')
 
     def __lt__(self, other):
         """
@@ -191,7 +233,7 @@ class Job(object):
 
     def __repr__(self):
         def format_time(t):
-            return t.strftime('%Y-%m-%d %H:%M:%S') if t else '[never]'
+            return t.strftime('%Y-%m-%d %H:%M:%S %Z') if t else '[never]'
 
         timestats = '(last run: %s, next run: %s)' % (
                     format_time(self.last_run), format_time(self.next_run))
@@ -205,6 +247,9 @@ class Job(object):
                   for k, v in self.job_func.keywords.items()]
         call_repr = job_func_name + '(' + ', '.join(args + kwargs) + ')'
 
+        self.job_name = call_repr
+        self.job_info = timestats
+
         if self.at_time is not None:
             return 'Every %s %s at %s do %s %s' % (
                    self.interval,
@@ -396,7 +441,14 @@ class Job(object):
         """
         :return: ``True`` if the job should be run now.
         """
-        return datetime.datetime.now() >= self.next_run
+        return datetime.datetime.now(utc) >= self.next_run
+
+    @property
+    def info(self):
+        """
+        :return: ``string`` with `job_func` name and timestats
+        """
+        return self.job_name + self.job_info
 
     def run(self):
         """
@@ -404,9 +456,9 @@ class Job(object):
 
         :return: The return value returned by the `job_func`
         """
-        logger.info('Running job %s', self)
+        self.logger.info('Running job %s', self)
         ret = self.job_func()
-        self.last_run = datetime.datetime.now()
+        self.last_run = datetime.datetime.now(utc)
         self._schedule_next_run()
         return ret
 
@@ -423,7 +475,7 @@ class Job(object):
             interval = self.interval
 
         self.period = datetime.timedelta(**{self.unit: interval})
-        self.next_run = datetime.datetime.now() + self.period
+        self.next_run = datetime.datetime.now(utc) + self.period
         if self.start_day is not None:
             assert self.unit == 'weeks'
             weekdays = (
@@ -454,7 +506,7 @@ class Job(object):
             # If we are running for the first time, make sure we run
             # at the specified time *today* (or *this hour*) as well
             if not self.last_run:
-                now = datetime.datetime.now()
+                now = datetime.datetime.now(utc)
                 if (self.unit == 'days' and self.at_time > now.time() and
                         self.interval == 1):
                     self.next_run = self.next_run - datetime.timedelta(days=1)
@@ -462,7 +514,7 @@ class Job(object):
                     self.next_run = self.next_run - datetime.timedelta(hours=1)
         if self.start_day is not None and self.at_time is not None:
             # Let's see if we will still make that time we specified today
-            if (self.next_run - datetime.datetime.now()).days >= 7:
+            if (self.next_run - datetime.datetime.now(utc)).days >= 7:
                 self.next_run -= self.period
 
 
@@ -490,11 +542,11 @@ def run_pending():
     default_scheduler.run_pending()
 
 
-def run_all(delay_seconds=0):
+def run_all(delay_seconds=0, tag=None):
     """Calls :meth:`run_all <Scheduler.run_all>` on the
     :data:`default scheduler instance <default_scheduler>`.
     """
-    default_scheduler.run_all(delay_seconds=delay_seconds)
+    default_scheduler.run_all(delay_seconds, tag)
 
 
 def clear(tag=None):
@@ -523,3 +575,17 @@ def idle_seconds():
     :data:`default scheduler instance <default_scheduler>`.
     """
     return default_scheduler.idle_seconds
+
+
+def last_run():
+    """Calls :meth:`last_run <Scheduler.last_run>` on the
+    :data:`default scheduler instance <default_scheduler>`.
+    """
+    return default_scheduler.last_run
+
+
+def idle_seconds_since():
+    """Calls :meth:`idle_seconds_since <Scheduler.idle_seconds_since>` on the
+    :data:`default scheduler instance <default_scheduler>`.
+    """
+    return default_scheduler.idle_seconds_since
diff --git a/schedule/parent_logger.py b/schedule/parent_logger.py
new file mode 100644
index 0000000..063ab26
--- /dev/null
+++ b/schedule/parent_logger.py
@@ -0,0 +1,32 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+import time
+import logging
+
+
+def setup_logging(debug):
+    """
+    Can be imported by ``<my_package>`` to create a log file for current
+    scheduler and job class logging.  In this example we use a ``debug``
+    flag set in ``<my_package>`` to change the Log Level.  We also use
+    UTC time and force the name in ``datefmt``.
+    """
+    if debug:
+        log_level = logging.getLevelName('DEBUG')
+    else:
+        log_level = logging.getLevelName('INFO')
+
+    logging.basicConfig(level=log_level,
+                        format="%(asctime)s %(name)s[%(process)d] %(levelname)s - %(message)s",
+                        datefmt='%Y-%m-%d %H:%M:%S UTC',
+                        filename='/var/log/scheduler.log')
+
+    # BUG: This does not print the TZ name because logging module uses
+    #      time instead of tz-aware datetime objects (so we force the
+    #      correct name in datefmt above).
+    logging.Formatter.converter = time.gmtime
+
+    # To also log parent info, try something like this
+    # global logger
+    # logger = logging.getLogger("my_package")
diff --git a/schedule/timezone.py b/schedule/timezone.py
new file mode 100644
index 0000000..1530e38
--- /dev/null
+++ b/schedule/timezone.py
@@ -0,0 +1,19 @@
+import datetime
+
+
+class UTC(datetime.tzinfo):
+    """tzinfo derived concrete class named "UTC" with offset of 0"""
+    # can be changed to another timezone name/offset
+    def __init__(self):
+        self.__offset = datetime.timedelta(seconds=0)
+        self.__dst = datetime.timedelta(0)
+        self.__name = "UTC"
+
+    def utcoffset(self, dt):
+        return self.__offset
+
+    def dst(self, dt):
+        return self.__dst
+
+    def tzname(self, dt):
+        return self.__name
diff --git a/test_schedule.py b/test_schedule.py
index 139745f..b56f932 100644
--- a/test_schedule.py
+++ b/test_schedule.py
@@ -1,4 +1,5 @@
 """Unit tests for schedule.py"""
+import sys
 import datetime
 import functools
 import mock
@@ -11,6 +12,13 @@ import unittest
 import schedule
 from schedule import every
 
+try:
+    from datetime import timezone
+    utc = timezone.utc
+except ImportError:
+    from schedule.timezone import UTC
+    utc = UTC()
+
 
 def make_mock_job(name=None):
     job = mock.Mock()
@@ -36,9 +44,10 @@ class mock_datetime(object):
                 return cls(self.year, self.month, self.day)
 
             @classmethod
-            def now(cls):
+            def now(cls, tz=None):
                 return cls(self.year, self.month, self.day,
-                           self.hour, self.minute)
+                           self.hour, self.minute).replace(tzinfo=tz)
+
         self.original_datetime = datetime.datetime
         datetime.datetime = MockDate
 
@@ -64,6 +73,22 @@ class SchedulerTests(unittest.TestCase):
         assert every().day.unit == every().days.unit
         assert every().week.unit == every().weeks.unit
 
+    def test_utc_is_normal(self):
+        fo = utc
+        self.assertIsInstance(fo, datetime.tzinfo)
+        dt = datetime.datetime.now(utc)
+        self.assertEqual(fo.utcoffset(dt), datetime.timedelta(0))
+        self.assertEqual(fo.tzname(dt), "UTC")
+
+    def test_utc_dst_is_dt(self):
+        fo = utc
+        dt = datetime.datetime.now()
+        if sys.version_info > (3, 0, 0):
+            dst_arg = None
+        else:
+            dst_arg = datetime.timedelta(0)
+        self.assertEqual(fo.dst(dt), dst_arg)
+
     def test_time_range(self):
         with mock_datetime(2014, 6, 28, 12, 0):
             mock_job = make_mock_job()
@@ -258,7 +283,8 @@ class SchedulerTests(unittest.TestCase):
             every().hour.do(hourly_job)
             assert len(schedule.jobs) == 2
             # Make sure the hourly job is first
-            assert schedule.next_run() == original_datetime(2010, 1, 6, 14, 16)
+            assert schedule.next_run() == original_datetime(2010, 1, 6, 14, 16,
+                                                            tzinfo=utc)
             assert schedule.idle_seconds() == 60 * 60
 
     def test_cancel_job(self):
